#summary mix-in tutorial
#labels tutorial
== Step.2 mix-in ==
 mix-inは単体では動作しないメソッドを定義します。そしてクラスに組み込み利用します。複数のクラスで汎用的に利用するメソッドを定義する場合に便利です。

 mix-inの定義ではどのクラスに組み込まれるか分からないので、組み込まれるクラスを決めることができません。組み込まれるクラスのインスタンスが変数になります。
 Negroniでは組み込まれるクラスのインスタンスを取得するためのインタフェース(MixinInterface)を用意しています。またmix-inのメソッドには@MixinMethodアノテーションを付与します。
 
 サンプルでは連携クラスをSystem.outに出力しています。
 * MixinSample
{{{
package example;

import org.lushlife.negroni.MixinInterface;
import org.lushlife.negroni.MixinMethod;

public class SampleMixinImpl implements SampleMixin, MixinInterface<Object> {
	private Object obj;
	// mix-inの実装
	@MixinMethod
	public void mixin() {
		System.out.println("mixin " + obj);
	}
	// 実装クラスのインスタンスを取得する
	public void setMixinInstance(Object instance) {
		this.obj = instance;
	}
}
}}}
 MixinInterface`<Object>`インタフェースを実装することでObject型を継承したクラス（つまりすべてのクラス）に組み込むことができるmix-inの定義となります(MixinInterfaceについてはMethodMappingで詳しく説明します)。
 SampleMixinインターフェースはmix-inインタフェースを定義しています。
 @Mixinedアノテーションによりmix-inクラスと連携させます。
 * SampleMixin
{{{
package example;

import org.lushlife.negroni.Mixined;

@Mixined(SampleMixinImpl.class)
public interface SampleMixin {
	// mix-in メソッド
	public void mixin();

}

}}}

 mix-inとクラスを連携させるには、mix-inインタフェースをimplementsに加えます。
 * MixInedSample
{{{
package example;

public abstract class SampleMixined implements SampleMixin {

}
}}}

 最後にEnhancerで実装クラスを生成してインスタンス化させて呼び出します。
 * MainSampleMixin
{{{
package example;

import org.lushlife.negroni.Enhancer;
import org.lushlife.negroni.Negroni;

public class MainSampleMixin {
	public static void main(String[] args) throws InstantiationException,
			IllegalAccessException {

		Enhancer enhancer = Negroni.create();
		Class<? extends SampleMixined> enhancedClass = enhancer
				.enhace(SampleMixined.class);

		SampleMixined mixinSample = enhancedClass.newInstance();
		mixinSample.mixin();
	}

}

}}}
 実行すると次のように出力されます。
 * 実行結果
{{{
mixin example.SampleMixined_negloni$$0@192059
}}}